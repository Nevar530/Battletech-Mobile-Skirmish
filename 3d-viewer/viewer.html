<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Battletech Map 3D Viewer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: #05070a;
      font-family: system-ui, sans-serif;
      color: #ccc;
    }
    #info {
      position: absolute;
      top: 8px;
      left: 10px;
      font-size: 12px;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      padding: 6px 10px;
      border-radius: 4px;
    }
    #fileBar {
      position: absolute;
      top: 8px;
      right: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
    }
    #fileInput {
      font-size: 11px;
      color: #ccc;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<div id="info">
  Battletech Map 3D Viewer<br/>
  • Drag = rotate · Scroll = zoom · Right-drag = pan<br/>
  • Default: test map · Or load your JSON export →
</div>

<div id="fileBar">
  Load map JSON:
  <input type="file" id="fileInput" accept=".json" />
</div>

<canvas id="viewer"></canvas>

<!-- Three.js + OrbitControls from unpkg (works on GitHub Pages) -->
<script src="https://unpkg.com/three/build/three.min.js"></script>
<script src="https://unpkg.com/three/examples/js/controls/OrbitControls.js"></script>

<script>
  // =========================
  // 1) DEFAULT TEST MAP
  //    (So you see *something* even before loading JSON)
  // =========================
  const TEST_MAP = {
    meta: {
      cols: 9,
      rows: 9,
      hexSize: 80
    },
    data: []
  };

  // Create a small diamond-shaped test field with varied heights/terrain
  for (let q = -4; q <= 4; q++) {
    for (let r = -4; r <= 4; r++) {
      if (Math.abs(q + r) > 4) continue;

      let ter = 5; // city core
      let h = 0;

      if ((q === 0 && r === 0) || (q === 1 && r === -1)) {
        ter = 2; // water
        h = -1;
      } else if (q === -1 && r === 1) {
        ter = 0; // road
        h = 0;
      } else if (q === 2 && r === -1) {
        ter = 4; // low urban
        h = 1;
      } else if (q === -2 && r === 1) {
        ter = 11; // trees/border
        h = 2;
      }

      TEST_MAP.data.push({ q, r, h, ter, cov: 0 });
    }
  }

  // =========================
  // 2) THREE.JS BASE SETUP
  // =========================
  const canvas = document.getElementById("viewer");
  let scene, camera, renderer, controls;

  initRenderer();
  buildSceneFromMap(TEST_MAP);
  animate();

  // Setup renderer, camera, controls once
  function initRenderer() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05070a);

    camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      1,
      100000
    );
    camera.position.set(0, 2000, 2000);

    renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;

    window.addEventListener("resize", onWindowResize);
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // =========================
  // 3) MAP → 3D SCENE BUILDER
  // =========================
  const SQRT3 = Math.sqrt(3);
  const LEVEL_HEIGHT = 40; // how tall each h-step renders

  function axialToWorld(q, r, size) {
    return {
      x: size * (1.5 * q),
      z: size * (SQRT3 * (r + q / 2))
    };
  }

  function terrainColor(ter) {
    switch (ter) {
      case 2:  return 0x204060; // water / canal
      case 4:  return 0x555555; // low urban / concrete
      case 5:  return 0x777777; // city core
      case 11: return 0x0a2b0a; // trees / border
      case 0:  return 0x333333; // roads
      default: return 0x888888;
    }
  }

  function clearScene() {
    // Remove all children from the scene
    while (scene.children.length > 0) {
      scene.remove(scene.children[0]);
    }
  }

  function buildSceneFromMap(mapData) {
    if (!mapData || !mapData.meta || !mapData.data) {
      alert("Invalid map JSON: expected { meta: {...}, data: [...] }");
      return;
    }

    const { meta, data } = mapData;
    const HEX_SIZE = meta.hexSize || 80;
    const HEX_RADIUS = HEX_SIZE * 0.5;

    clearScene();

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambient);

    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(1000, 2000, 1000);
    scene.add(dir);

    // Hex geometry – cylinder with 6 sides, upright
    const baseHexGeom = new THREE.CylinderGeometry(HEX_RADIUS, HEX_RADIUS, 1, 6);

    let minX = Infinity, maxX = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    let minY = Infinity, maxY = -Infinity;

    data.forEach(cell => {
      const q = cell.q ?? 0;
      const r = cell.r ?? 0;
      const h = cell.h ?? 0;
      const ter = cell.ter ?? 5;

      const { x, z } = axialToWorld(q, r, HEX_SIZE);

      const mat = new THREE.MeshStandardMaterial({
        color: terrainColor(ter),
        roughness: 0.9,
        metalness: 0.0
      });

      const mesh = new THREE.Mesh(baseHexGeom, mat);

      const thickness = LEVEL_HEIGHT * 0.8;
      mesh.scale.set(1, thickness, 1);

      const yTop = h * LEVEL_HEIGHT;
      const yCenter = yTop + thickness / 2;

      mesh.position.set(x, yCenter, z);
      scene.add(mesh);

      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minZ = Math.min(minZ, z);
      maxZ = Math.max(maxZ, z);
      minY = Math.min(minY, yTop);
      maxY = Math.max(maxY, yTop);
    });

    if (!isFinite(minX)) {
      // no cells – nothing to show
      return;
    }

    // Ground plane
    const spanX = maxX - minX;
    const spanZ = maxZ - minZ;
    const groundSize = Math.max(spanX, spanZ) * 1.6 || 2000;

    const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize);
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x111111,
      roughness: 1.0,
      metalness: 0.0
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = (minY === Infinity ? 0 : minY) - LEVEL_HEIGHT * 1.5;
    scene.add(ground);

    // Center camera & controls
    const centerX = (minX + maxX) / 2;
    const centerZ = (minZ + maxZ) / 2;
    const centerY = (minY + maxY) / 2;

    controls.target.set(centerX, centerY, centerZ);
    controls.update();

    camera.position.set(
      centerX - 3 * HEX_SIZE,
      centerY + 8 * LEVEL_HEIGHT,
      centerZ + 6 * HEX_SIZE
    );
  }

  // =========================
  // 4) FILE INPUT → LOAD JSON
  // =========================
  const fileInput = document.getElementById("fileInput");

  fileInput.addEventListener("change", (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const text = ev.target.result;
        const json = JSON.parse(text);

        // Expect { meta: { cols, rows, hexSize }, data: [ { q, r, h, ter, cov }, ... ] }
        if (!json.meta || !Array.isArray(json.data)) {
          alert("JSON loaded, but format is not { meta: {...}, data: [...] }");
          return;
        }

        buildSceneFromMap(json);
      } catch (err) {
        console.error(err);
        alert("Failed to parse JSON: " + err.message);
      }
    };
    reader.readAsText(file);
  });

  // =========================
  // 5) RENDER LOOP
  // =========================
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
</script>
</body>
</html>
